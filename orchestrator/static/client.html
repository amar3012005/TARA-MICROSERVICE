<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Leibniz Voice Agent - Unified Client</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            color: #333;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 16px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
        }
        header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }
        header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }
        header p {
            opacity: 0.9;
            font-size: 1.1em;
        }
        .content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            padding: 30px;
        }
        @media (max-width: 768px) {
            .content {
                grid-template-columns: 1fr;
            }
        }
        .panel {
            background: #f8f9fa;
            border-radius: 12px;
            padding: 20px;
            border: 2px solid #e9ecef;
        }
        .panel h2 {
            color: #667eea;
            margin-bottom: 15px;
            font-size: 1.5em;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .status {
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            font-weight: bold;
            text-align: center;
            transition: all 0.3s;
        }
        .status.disconnected { background: #f8d7da; color: #721c24; }
        .status.connecting { background: #fff3cd; color: #856404; }
        .status.connected { background: #d4edda; color: #155724; }
        .status.listening { background: #cfe2ff; color: #084298; }
        .status.speaking { background: #fff3cd; color: #856404; }
        .status.thinking { background: #e7f3ff; color: #055160; }
        button {
            padding: 12px 24px;
            font-size: 1em;
            cursor: pointer;
            border: none;
            border-radius: 8px;
            font-weight: bold;
            transition: all 0.3s;
            margin: 5px;
        }
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .btn-primary {
            background: #667eea;
            color: white;
        }
        .btn-primary:hover:not(:disabled) {
            background: #5568d3;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }
        .btn-danger {
            background: #e74c3c;
            color: white;
        }
        .btn-danger:hover:not(:disabled) {
            background: #c0392b;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(231, 76, 60, 0.4);
        }
        .btn-success {
            background: #28a745;
            color: white;
        }
        .btn-success:hover:not(:disabled) {
            background: #218838;
            transform: translateY(-2px);
        }
        .transcripts, .logs {
            max-height: 400px;
            overflow-y: auto;
            background: white;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            padding: 15px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }
        .transcript-item, .log-item {
            padding: 8px;
            margin-bottom: 8px;
            border-left: 3px solid #667eea;
            background: #f8f9fa;
            border-radius: 4px;
        }
        .transcript-item.final {
            border-left-color: #28a745;
            background: #d4edda;
            font-weight: bold;
        }
        .transcript-item.fragment {
            border-left-color: #ffc107;
            opacity: 0.7;
        }
        .log-item.info { border-left-color: #17a2b8; }
        .log-item.warning { border-left-color: #ffc107; }
        .log-item.error { border-left-color: #dc3545; }
        .log-item.success { border-left-color: #28a745; }
        .audio-visualizer {
            height: 100px;
            background: #f8f9fa;
            border-radius: 8px;
            margin: 15px 0;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 2px dashed #dee2e6;
        }
        .audio-visualizer.active {
            border-color: #667eea;
            background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
            animation: pulse 1.5s ease-in-out infinite;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        .controls {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-bottom: 20px;
        }
        .session-info {
            background: #e7f3ff;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            font-size: 0.9em;
        }
        .session-info strong {
            color: #667eea;
        }
        .mode-badge {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.8em;
            font-weight: bold;
            margin-left: 10px;
        }
        .mode-badge.unified {
            background: #28a745;
            color: white;
        }
        .mode-badge.legacy {
            background: #6c757d;
            color: white;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>ğŸ™ï¸ Leibniz Voice Agent</h1>
            <p>Phase 1: Single WebSocket Client <span class="mode-badge unified">UNIFIED</span></p>
        </header>
        
        <div class="content">
            <!-- Left Panel: Audio Input -->
            <div class="panel">
                <h2>ğŸ¤ Audio Input</h2>
                <div id="inputStatus" class="status disconnected">Disconnected</div>
                <div class="session-info">
                    <strong>Connection:</strong> Single WebSocket at <code>/ws</code><br>
                    <strong>Session ID:</strong> <span id="sessionId">-</span><br>
                    <strong>Mode:</strong> Unified bidirectional
                </div>
                <div class="audio-visualizer" id="inputVisualizer">
                    <span style="color: #999;">Microphone Input</span>
                </div>
                <div class="controls">
                    <button id="startSession" class="btn-success">Start Session</button>
                    <button id="startMic" class="btn-primary" disabled>Start Microphone</button>
                    <button id="stopMic" class="btn-danger" disabled>Stop Microphone</button>
                </div>
                <h3>Transcripts</h3>
                <div id="transcripts" class="transcripts"></div>
            </div>
            
            <!-- Right Panel: Audio Output -->
            <div class="panel">
                <h2>ğŸ”Š Audio Output</h2>
                <div id="outputStatus" class="status disconnected">Disconnected</div>
                <div class="session-info">
                    <strong>State:</strong> <span id="currentState">-</span><br>
                    <strong>Audio Chunks:</strong> <span id="chunkCount">0</span> received<br>
                    <strong>Playback:</strong> <span id="playbackStatus">Idle</span>
                </div>
                <div class="audio-visualizer" id="outputVisualizer">
                    <span style="color: #999;">Audio Output</span>
                </div>
                <div class="controls">
                    <button id="endSession" class="btn-danger" disabled>End Session</button>
                    <button id="interrupt" class="btn-primary" disabled>Interrupt</button>
                </div>
                <h3>System Logs</h3>
                <div id="logs" class="logs"></div>
            </div>
        </div>
    </div>

    <script>
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // PHASE 1: SINGLE WEBSOCKET CLIENT
        // Unified bidirectional connection - sends audio, receives TTS via same socket
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        const SAMPLE_RATE = 16000;
        const WS_URL = window.location.protocol === 'https:' 
            ? `wss://${window.location.host}/ws` 
            : `ws://${window.location.host}/ws`;
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // OrchestratorClient: Single unified WebSocket connection
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        class OrchestratorClient {
            constructor() {
                this.ws = null;
                this.sessionId = null;
                this.state = 'idle';
                this.audioContext = null;
                this.audioQueue = [];
                this.isProcessingQueue = false;
                this.isPlayingAudio = false;
                this.playbackStartTime = null;
                this.currentSource = null;
                this.chunkCount = 0;
                
                // Microphone state
                this.mediaStream = null;
                this.micAudioContext = null;
                this.processor = null;
                this.isMicActive = false;
                
                this.setupUI();
            }
            
            setupUI() {
                // DOM Elements
                this.inputStatus = document.getElementById('inputStatus');
                this.outputStatus = document.getElementById('outputStatus');
                this.sessionIdEl = document.getElementById('sessionId');
                this.currentStateEl = document.getElementById('currentState');
                this.chunkCountEl = document.getElementById('chunkCount');
                this.playbackStatusEl = document.getElementById('playbackStatus');
                this.inputVisualizer = document.getElementById('inputVisualizer');
                this.outputVisualizer = document.getElementById('outputVisualizer');
                this.transcripts = document.getElementById('transcripts');
                this.logs = document.getElementById('logs');
                
                // Buttons
                this.startSessionBtn = document.getElementById('startSession');
                this.startMicBtn = document.getElementById('startMic');
                this.stopMicBtn = document.getElementById('stopMic');
                this.endSessionBtn = document.getElementById('endSession');
                this.interruptBtn = document.getElementById('interrupt');
                
                // Event handlers
                this.startSessionBtn.onclick = () => this.connect();
                this.startMicBtn.onclick = () => this.startMicrophone();
                this.stopMicBtn.onclick = () => this.stopMicrophone();
                this.endSessionBtn.onclick = () => this.endSession();
                this.interruptBtn.onclick = () => this.interrupt();
            }
            
            // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            // WebSocket Connection
            // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            
            connect() {
                if (this.ws && this.ws.readyState === WebSocket.OPEN) {
                    this.addLog('Already connected', 'warning');
                    return;
                }
                
                this.updateStatus(this.inputStatus, 'connecting', 'Connecting...');
                this.updateStatus(this.outputStatus, 'connecting', 'Connecting...');
                this.addLog('Connecting to orchestrator...', 'info');
                
                this.ws = new WebSocket(WS_URL);
                
                this.ws.onopen = () => {
                    this.addLog('âœ… WebSocket connected', 'success');
                    this.updateStatus(this.inputStatus, 'connected', 'Connected');
                    this.updateStatus(this.outputStatus, 'connected', 'Connected');
                    
                    this.startSessionBtn.disabled = true;
                    this.startMicBtn.disabled = false;
                    this.endSessionBtn.disabled = false;
                    
                    // Request session start
                    this.send({ type: 'start_session', mode: 'conversation' });
                };
                
                this.ws.onmessage = async (event) => {
                    try {
                        const data = JSON.parse(event.data);
                        await this.handleMessage(data);
                    } catch (e) {
                        console.error('Error handling message:', e);
                    }
                };
                
                this.ws.onerror = (error) => {
                    this.addLog(`âŒ WebSocket error`, 'error');
                    this.updateStatus(this.inputStatus, 'disconnected', 'Error');
                    this.updateStatus(this.outputStatus, 'disconnected', 'Error');
                };
                
                this.ws.onclose = () => {
                    this.addLog('WebSocket disconnected', 'warning');
                    this.updateStatus(this.inputStatus, 'disconnected', 'Disconnected');
                    this.updateStatus(this.outputStatus, 'disconnected', 'Disconnected');
                    this.ws = null;
                    this.sessionId = null;
                    
                    this.startSessionBtn.disabled = false;
                    this.startMicBtn.disabled = true;
                    this.stopMicBtn.disabled = true;
                    this.endSessionBtn.disabled = true;
                    this.interruptBtn.disabled = true;
                };
            }
            
            send(data) {
                if (this.ws && this.ws.readyState === WebSocket.OPEN) {
                    this.ws.send(JSON.stringify(data));
                }
            }
            
            // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            // Message Handling
            // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            
            async handleMessage(data) {
                const { type } = data;
                
                switch (type) {
                    case 'session_ready':
                        this.sessionId = data.session_id;
                        this.sessionIdEl.textContent = this.sessionId;
                        this.addLog(`âœ… Session ready: ${this.sessionId}`, 'success');
                        break;
                    
                    case 'state_update':
                        this.state = data.state;
                        this.currentStateEl.textContent = data.state;
                        this.updateStateUI(data.state);
                        break;
                    
                    case 'transcript':
                        this.addTranscript(data.text, data.is_final);
                        break;
                    
                    case 'agent_response':
                        if (data.is_complete) {
                            this.addLog(`ğŸ¤– Response: ${data.full_text?.substring(0, 50)}...`, 'success');
                        }
                        break;
                    
                    case 'audio_chunk':
                        if (data.is_final) {
                            this.addLog('ğŸ”Š Audio stream complete', 'info');
                        } else if (data.audio) {
                            await this.queueAudio(data.audio);
                        }
                        break;
                    
                    case 'playback_control':
                        if (data.action === 'stop') {
                            this.stopPlayback();
                            this.addLog(`âš¡ Playback stopped: ${data.reason}`, 'warning');
                        }
                        break;
                    
                    default:
                        this.addLog(`ğŸ“¨ ${type}: ${JSON.stringify(data).substring(0, 100)}`, 'info');
                }
            }
            
            updateStateUI(state) {
                if (state === 'listening') {
                    this.updateStatus(this.outputStatus, 'listening', 'Listening...');
                    this.interruptBtn.disabled = true;
                } else if (state === 'thinking') {
                    this.updateStatus(this.outputStatus, 'thinking', 'Thinking...');
                    this.interruptBtn.disabled = true;
                } else if (state === 'speaking') {
                    this.updateStatus(this.outputStatus, 'speaking', 'Speaking...');
                    this.outputVisualizer.classList.add('active');
                    this.interruptBtn.disabled = false;
                } else {
                    this.updateStatus(this.outputStatus, 'connected', 'Ready');
                    this.outputVisualizer.classList.remove('active');
                    this.interruptBtn.disabled = true;
                }
            }
            
            // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            // Microphone Handling
            // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            
            async startMicrophone() {
                try {
                    this.mediaStream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    this.micAudioContext = new AudioContext({ sampleRate: SAMPLE_RATE });
                    const source = this.micAudioContext.createMediaStreamSource(this.mediaStream);
                    this.processor = this.micAudioContext.createScriptProcessor(4096, 1, 1);
                    
                    source.connect(this.processor);
                    this.processor.connect(this.micAudioContext.destination);
                    
                    // Voice activity detection for barge-in
                    const VAD_THRESHOLD = 0.02;
                    let consecutiveVoiceFrames = 0;
                    const VOICE_FRAMES_FOR_BARGE_IN = 3;
                    
                    this.processor.onaudioprocess = (e) => {
                        if (!this.ws || this.ws.readyState !== WebSocket.OPEN) return;
                        
                        const inputData = e.inputBuffer.getChannelData(0);
                        const pcmData = new Int16Array(inputData.length);
                        
                        // Calculate RMS for VAD
                        let sum = 0;
                        for (let i = 0; i < inputData.length; i++) {
                            pcmData[i] = Math.max(-1, Math.min(1, inputData[i])) * 0x7FFF;
                            sum += inputData[i] * inputData[i];
                        }
                        const rms = Math.sqrt(sum / inputData.length);
                        
                        // Barge-in detection
                        if (rms > VAD_THRESHOLD) {
                            consecutiveVoiceFrames++;
                            if (this.isPlayingAudio && consecutiveVoiceFrames >= VOICE_FRAMES_FOR_BARGE_IN) {
                                this.interrupt();
                                consecutiveVoiceFrames = 0;
                            }
                        } else {
                            consecutiveVoiceFrames = 0;
                        }
                        
                        // Send audio chunk (base64 encoded)
                        const audioB64 = this.arrayBufferToBase64(pcmData.buffer);
                        this.send({
                            type: 'audio_chunk',
                            data: audioB64,
                            timestamp: Date.now() / 1000,
                            sequence: this.chunkCount++
                        });
                        
                        this.inputVisualizer.classList.add('active');
                    };
                    
                    this.isMicActive = true;
                    this.startMicBtn.disabled = true;
                    this.stopMicBtn.disabled = false;
                    this.updateStatus(this.inputStatus, 'listening', 'Recording...');
                    this.addLog('ğŸ¤ Microphone started', 'success');
                    
                } catch (err) {
                    this.addLog(`âŒ Microphone error: ${err.message}`, 'error');
                }
            }
            
            stopMicrophone() {
                if (this.mediaStream) {
                    this.mediaStream.getTracks().forEach(track => track.stop());
                }
                if (this.micAudioContext) {
                    this.micAudioContext.close();
                }
                
                this.isMicActive = false;
                this.startMicBtn.disabled = false;
                this.stopMicBtn.disabled = true;
                this.inputVisualizer.classList.remove('active');
                this.updateStatus(this.inputStatus, 'connected', 'Microphone stopped');
                this.addLog('ğŸ›‘ Microphone stopped', 'info');
            }
            
            // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            // Audio Playback
            // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            
            async queueAudio(audioB64) {
                if (!this.audioContext) {
                    this.audioContext = new AudioContext({ sampleRate: 24000 });
                }
                
                try {
                    const audioBytes = Uint8Array.from(atob(audioB64), c => c.charCodeAt(0));
                    
                    // Convert raw PCM to playable format
                    const audioBuffer = this.audioContext.createBuffer(1, audioBytes.length / 2, 24000);
                    const channelData = audioBuffer.getChannelData(0);
                    const int16View = new Int16Array(audioBytes.buffer);
                    
                    for (let i = 0; i < int16View.length; i++) {
                        channelData[i] = int16View[i] / 32768.0;
                    }
                    
                    this.audioQueue.push(audioBuffer);
                    this.chunkCount++;
                    this.chunkCountEl.textContent = this.chunkCount;
                    
                    if (!this.isProcessingQueue) {
                        this.processAudioQueue();
                    }
                } catch (error) {
                    console.error('Audio decode error:', error);
                }
            }
            
            async processAudioQueue() {
                if (this.isProcessingQueue || this.audioQueue.length === 0) return;
                
                this.isProcessingQueue = true;
                
                while (this.audioQueue.length > 0) {
                    const audioBuffer = this.audioQueue.shift();
                    
                    if (!this.isPlayingAudio) {
                        this.isPlayingAudio = true;
                        this.playbackStartTime = Date.now();
                        this.playbackStatusEl.textContent = 'Playing...';
                        this.outputVisualizer.classList.add('active');
                    }
                    
                    await this.playAudioBuffer(audioBuffer);
                }
                
                // All audio played
                if (this.isPlayingAudio) {
                    this.isPlayingAudio = false;
                    this.playbackStatusEl.textContent = 'Complete';
                    this.outputVisualizer.classList.remove('active');
                    
                    const duration = this.playbackStartTime ? Date.now() - this.playbackStartTime : 0;
                    this.addLog(`ğŸ”Š Playback complete (${duration}ms)`, 'info');
                    
                    // Notify server
                    this.send({
                        type: 'playback_done',
                        duration_ms: duration,
                        timestamp: Date.now() / 1000
                    });
                    
                    this.playbackStartTime = null;
                }
                
                this.isProcessingQueue = false;
            }
            
            playAudioBuffer(audioBuffer) {
                return new Promise((resolve) => {
                    const source = this.audioContext.createBufferSource();
                    source.buffer = audioBuffer;
                    source.connect(this.audioContext.destination);
                    
                    this.currentSource = source;
                    source.onended = () => {
                        this.currentSource = null;
                        resolve();
                    };
                    
                    source.start();
                });
            }
            
            stopPlayback() {
                if (this.currentSource) {
                    try {
                        this.currentSource.stop();
                    } catch (e) {}
                    this.currentSource = null;
                }
                
                this.audioQueue = [];
                this.isPlayingAudio = false;
                this.isProcessingQueue = false;
                this.playbackStatusEl.textContent = 'Stopped';
                this.outputVisualizer.classList.remove('active');
            }
            
            // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            // Session Control
            // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            
            interrupt() {
                if (!this.isPlayingAudio) return;
                
                this.addLog('âš¡ Interrupt sent', 'warning');
                this.stopPlayback();
                
                this.send({
                    type: 'interrupt',
                    reason: 'user_speaking',
                    timestamp: Date.now() / 1000
                });
            }
            
            endSession() {
                this.stopMicrophone();
                this.stopPlayback();
                
                this.send({ type: 'end_session' });
                
                if (this.ws) {
                    this.ws.close();
                }
            }
            
            // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            // Utilities
            // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            
            arrayBufferToBase64(buffer) {
                let binary = '';
                const bytes = new Uint8Array(buffer);
                for (let i = 0; i < bytes.byteLength; i++) {
                    binary += String.fromCharCode(bytes[i]);
                }
                return btoa(binary);
            }
            
            updateStatus(element, status, message) {
                element.className = `status ${status}`;
                element.textContent = message;
            }
            
            addLog(message, type = 'info') {
                const logItem = document.createElement('div');
                logItem.className = `log-item ${type}`;
                logItem.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
                this.logs.appendChild(logItem);
                this.logs.scrollTop = this.logs.scrollHeight;
            }
            
            addTranscript(text, isFinal = false) {
                const item = document.createElement('div');
                item.className = `transcript-item ${isFinal ? 'final' : 'fragment'}`;
                item.textContent = `[${new Date().toLocaleTimeString()}] ${text}`;
                this.transcripts.appendChild(item);
                this.transcripts.scrollTop = this.transcripts.scrollHeight;
            }
        }
        
        // Initialize client
        const client = new OrchestratorClient();
        
        // Log ready state
        window.addEventListener('load', () => {
            client.addLog('ğŸš€ Page loaded - click "Start Session" to connect', 'info');
        });
    </script>
</body>
</html>
